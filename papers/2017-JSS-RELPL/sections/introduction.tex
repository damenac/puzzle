\section{Introduction}

The increasing complexity of modern software systems has motivated the need of raising the level of abstraction at which software is designed and implemented \cite{Chechik:2010}. The use of domain-specific languages (DSLs) has emerged in response to this need as an alternative to express software solutions in relevant domain concepts, thus favoring separation of concerns and hiding fine-grained implementation details \cite{Jezequel:2014}. DSLs are software languages whose expressiveness is focused on a well defined domain and which provide abstractions a.k.a., \textit{language constructs} that address a specific purpose \cite{Mernik:2005b}. The adoption of such a language-oriented vision has motivated the construction of a large variety of DSLs. There are, for example, DSLs to build graphical user interfaces \cite{Oney:2012}, to specify security policies \cite{Lodderstedt:2002}, or to ease off mobile applications' prototyping \cite{Ribeiro:2014}.

Despite all the advantages furnished by DSLs in terms of abstraction and separation of concerns, this approach has also important drawbacks that put into question its benefits \cite{Gray:2008}. One of those drawbacks is associated to the elevated costs of the language development process. The construction of DSLs is a time consuming activity that requires specialized background \cite{Jezequel:2014}; language designers must own solid modeling skills and technical knowledge to conduct the definition of complex artifacts such as metamodels, grammars, interpreters, or compilers \cite{Jezequel:2014}.

The development of DSLs becomes more complex when we consider that DSLs often have many \textit{variants}. A variant is a new version of a given DSL that introduces certain differences in terms of syntax and/or semantics \cite{Homer:2014}. Typically, language variants appear under two situations. The first situation is the use of well-known formalisms through different domains. Consider the case of finite state machines, which have been used in a the construction of DSLs for a large spectrum of domains such as definition of graphical user interfaces \cite{Oney:2012} or games prototyping \cite{Funk:2012}. Those DSLs share typical state machine concepts such as states or transitions. However, each DSL adapts those abstractions to address the particularities of its domain. 

The second situation that favors the existence of DSL variants is when the complexity of a given domain requires the construction of several DSLs with different purposes. In such a case, the domain abstractions of the DSLs are similar, but their concrete implementations require adaptations. For instance, suppose two DSLs: the former is a DSL for specification and verification of railway scheme plans \cite{James:2014}; the latter is a DSL for modeling and reasoning on railway systems' capacity and security \cite{Iliasov:2013}. These DSL share certain domain abstractions i.e., railway management. However, they both require different semantics and specialized constructs to achieve their purposes.

The phenomenon of DSL variants is not a problem itself but reflects the abstraction power of certain well-known formalisms --such as state machines or petri nets-- that, with proper adaptations, can fit various domains. Besides, it shows how different issues in a same domain can be addressed by diverse and complementary DSLs. Nevertheless, when the same team of language designers has to deal not only with the construction of DSLs but also with the definition of several variants, then their work becomes even more challenging. After all, at implementation level each DSL variant is a complete language itself requiring tooling such as editors, interpreters, compilers, and so on.

In this context, the challenge for language designers is to take advantage of the commonalities existing among DSL variants by reusing, as much as possible, formerly defined language constructs \cite{Zschaler:2010}. The objective is to leverage previous engineering efforts to minimize implementation from scratch. To achieve such a challenge, the research community in software language engineering has proposed the use of Software Product Line Engineering (SPLE) in the construction of DSLs \cite{White:2009}. This led to the notion of \textit{Language Product Line Engineering (LPLE)}, i.e., the construction of software product lines where the products are languages \cite{Zschaler:2010,Kuhn:2015}.

Similarly to software product lines, language product lines can be built through two different approaches: top-down and bottom-up \cite{Kuhn:2016}. In the top-down approach, a language product line is designed and implemented through a domain analysis process where the knowledge owned by experts and final users is used to define a set of language modules that implement the language features of the product line. Also, the domain knowledge is used to specify variability models capturing the rules that define the way in which the language features can be combined to produce valid DSLs. In the bottom-up approach, the language product line is built up from a set of existing DSL variants through reverse-engineering techniques. Those techniques should provide mechanisms for: (1) recovering of a language modular design including all the language constructs existing in the DSL variants; and (2) synthesis of the corresponding variability models. %While there are several research works supporting top-down language product line engineering (e.g., \cite{White:2009,Zschaler:2010,Vacchi:2013}), the bottom-up approach is rarely studied.

In a previous work \cite{MendezAcuna:2016}, we introduced an approach to automatically infer a language modular design from a given set of DSL variants. In this article, we extend that work to provide a complete reverse-engineering technique that produces not only the language modular designs, but the entire language product line. In that sense, the delta of this article with respect to the previous one is the synthesis of the variability models. Those variability models are specified in terms of well-known formalisms  i.e., feature models (FM) and orthogonal variability models (OVM) in such a way that they encode the variability of a language product line in a compact way while considering the diverse dimensions that such a variability may present. We also show how those variability models can be used to configure and assembly new DSL variants.

We validate our approach through the implementation of a case study, which is composed of three variants of a DSL for finite-state machines \cite{Crane:2007}. We use this case study as an oracle, which means that we know in advance the existing variation points. Then, we execute our approach on these DSL variants and we compare the produced results against the expected ones. The result of this comparison shows that our reverse engineering technique is correct since all the detected variation points correspond to real differences in the DSL variants. Also, this validation allowed us to identify certain threats to validity regarding the level of granularity of the detected variation points. 

The remainder of this article is structured as follows: Section \ref{sec:problemstatement} describes the problem statement. Section \ref{sec:approach} introduces our approach. Section \ref{sec:validation} presents the case study that we use as a validation. Section \ref{sec:relatedwork} discusses the related work. Finally, Section \ref{sec:conclusions} concludes the article. 