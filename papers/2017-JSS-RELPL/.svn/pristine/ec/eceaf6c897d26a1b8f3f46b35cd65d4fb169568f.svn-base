\section{Introduction}

The increasing complexity of modern software systems has motivated the need of raising the level of abstraction at which software is designed and implemented \cite{Chechik:2010}. The use of domain-specific languages (DSLs) has emerged in response of this need as an alternative to express software solutions in relevant domain concepts, thus favoring separation of concerns and hiding fine-grained implementation details \cite{Jezequel:2014}. DSLs are software languages whose expressiveness is focused to a well defined domain, and which provide abstractions a.k.a., \textit{language constructs} that address a specific purpose \cite{Mernik:2005b}. The adoption of such a language-oriented vision has produced a large variety of DSLs. There are, for example, DSLs to build graphical user interfaces \cite{Oney:2012}, to specify security policies \cite{Lodderstedt:2002}, or to ease off games prototyping \cite{Funk:2012}.

Despite all the advantages furnished by DSLs in terms of abstraction and separation of concerns, this approach has also important drawbacks that put into question its benefits \cite{Gray:2008}. One of those drawbacks is associated to the elevated costs of the language development process. The construction of DSLs is a time consuming activity that requires specialized background \cite{Jezequel:2014}. Language designers must own quite solid modeling skills as well as technical knowledge enough to conduct the definition of complex artifacts such as metamodels, grammars, interpreters, or compilers \cite{Jezequel:2014}. It is worth the effort to build a DSL? That question is not always easy to answer \cite{Gray:2008}. 

The situation becomes more complex when we consider that, as the same as natural languages, DSLs often have different \textit{dialects} \cite{Homer:2014}. A language dialect is a variation of a given DSL that introduces certain differences in terms of syntax and/or semantics. This type of variations appear under two situations. The first situation is when the complexity of a given domain demands the construction of several DSLs with different purposes. In such a case, the domain abstractions of the DSLs are similar but the specificities of the specific purposes require adaptations. Suppose, for example, two DSLs: the former is a DSL for specification and verification of railway scheme plans \cite{James:2014}; the latter is a DSL for modeling and reasoning on railway systems' capacity and security \cite{Iliasov:2013}. Certainly, these DSL share the same domain (i.e., railway management); hence, they share certain domain abstractions. However, each of DSL requires different semantics and specialized constructs to achieve its purpose.

The second situation that favors the existence of DSLs variants is the use of well-known formalisms through different domains. As an example, consider the case of finite state machines (FSMs). Generally speaking, a FSM is a directed graph where nodes are states and arcs are transitions between the states. However, FSMs have been used in a the construction of DSLs for a large spectrum of domains and application contexts. Naturally, a DSL inspired in FSM for building graphical user interfaces \cite{Oney:2012} requires different semantics and specialized constructs \textit{w.r.t.} a DSL based on FSMs for games prototyping \cite{Funk:2012}.

Note that the phenomenon of DSLs variants is not a problem itself. Contrariwise, it shows how different issues in a same domain can be addressed by different and complementary DSLs. Besides, it reflects the abstraction power of certain well-known formalisms --such as state machines or petri nets-- that with proper adaptations result useful in several domains. However, when the same team of language designers has to deal not only with the construction of DSLs, but also with the definition of several variants, then their work becomes even more challenging and the costs of the language development process increase. After all, at implementation level each variant is a complete language itself requiring all the associated tooling such as editors, validators, interpreters, compilers, and so on.

In this context, the challenge for language designers is to take advantage of the commonalities existing among similar DSLs by reusing, as much as possible, formerly defined language constructs \cite{Zschaler:2010}. The objective is to leverage previous engineering efforts to minimize implementation from scratch. To this end, the research community in software language engineering has proposed the use of Software Product Line Engineering (SPLE) in the construction of DSLs \cite{White:2009}. Indeed, the notion of \textit{Language Product Line Engineering (LPLE)} --i.e., the construction of software product lines where the products are languages-- has been recently introduced \cite{Zschaler:2010,Kuhn:2015}.

Similarly than in the general case of software product lines, language product lines can be built from two different approaches: top-down, and bottom-up \cite{Kuhn:2016}. In top-down approach, a language product line is build up through a domain analysis process where the knowledge owned by experts and final users is capitalized in a language modular design and variability models. Differently, in the bottom-up approach the language product line is built up from a set of existing DSL variants. Nowadays, we can find several approaches supporting top-down language product line engineering. However, the bottom-up approach is rarely studied.

In this article, we aim to contribute in the construction of bottom-up language product lines. Concretely, we introduce a set of meta-language facilities that support the specification of a language product line. Then, we provide a reverse engineering process to automatically produce a language product line from a set of existing DSLs. This process starts with some static analysis that takes the existing DSLs and identify the commonalities and particularities to extract them a set of interdependent language modules. We also provide an approach to synthesize the corresponding variability models that permit the configuration of particular DSLs. We validate our approach through the implementation of a case study on finite state machines. 

The remainder of this article is structured as follows: Section \ref{sec:problemstatement} describes the development scenario behind bottom up language product lines, thus characterizing the situation in which our approach results useful. Section \ref{sec:approach} introduces our approach. Section \ref{sec:validation} presents the case study that we use as a validation of our approach. Section \ref{sec:relatedwork} presents a comparison of our approach with the related work. Finally, Section \ref{sec:conclusions} concludes the article. 