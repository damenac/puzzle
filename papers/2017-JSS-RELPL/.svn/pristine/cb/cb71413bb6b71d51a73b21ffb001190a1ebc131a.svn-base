\section{Introduction}

The increasing complexity of modern software systems has motivated the need of raising the level of abstraction at which software is designed and implemented \cite{Chechik:2010}. The use of domain-specific languages (DSLs) has emerged in response of this need as an alternative to express software solutions in relevant domain concepts, thus favoring separation of concerns and hiding fine-grained implementation details \cite{Jezequel:2014}. DSLs are software languages whose expressiveness is focused to a well defined domain, and which provide the abstractions a.k.a., \textit{language constructs} needed to describe certain aspect of a system under construction \cite{Combemale:2014}.

Naturally, the adoption of such a language-oriented vision relies on the availability of the DSLs needed to describe all the aspects of the system \cite{Clark:2013}; consequently, nowadays there is a large variety of DSLs conceived for diverse application contexts \cite{Mernik:2005b}. There are, for example, DSLs to build graphical user interfaces \cite{Oney:2012}, to specify security policies \cite{Lodderstedt:2002}, or to ease off games prototyping \cite{Funk:2012}.

Although each of the existing DSLs is unique and has been developed for a precise purpose while targeting a specific application context, not all the existing DSLs are completely different among them. Recent research has shown the existence of DSLs providing similar language constructs \cite{Zschaler:2010b,Lara:2012}. A possible explanation to such phenomenon is the recurrent use of certain modeling patterns that, with proper adaptations, are suitable in several application contexts. For instance, finite state machines have inspired many DSLs dealing with diverse problems such as the design of integrated circuits \cite{Agron:2009}, performing software components composition \cite{Anlauff:2000}, or the alignment of business processes with legislation \cite{Neskovic:2011}.

In this context, the challenge for language designers is to take advantage of the commonalities existing among similar DSLs by reusing, as much as possible, formerly defined language constructs \cite{Zschaler:2010}. The objective is to leverage previous engineering efforts to minimize implementation from scratch. This is a valuable opportunity to reduce the development costs of DSLs which, as a matter of fact, are quite elevated to the point that they limit the ultimate value of DSLs. The construction of DSLs is a complex development activity that requires specialized knowledge and skills \cite{Jezequel:2014}. 

%Ideally, the reuse process should be systematic. This requires, on one hand, the capability of defining reusable segments of language specifications that can be included in the definition of several DSLs, and on other hand, an appropriate management of the variability introduced by the particularities of each DSL \cite{Liebig:2013}.

In order to overcome this challenge, the research community in software language engineering has proposed the use of Software Product Lines Engineering (\textbf{S}PLE) in the construction of DSLs \cite{White:2009}. Indeed, the notion of \textit{Language Product Lines (LPL)} --i.e., software product lines where the products are languages -- has been recently introduced \cite{Zschaler:2010,Kuhn:2015}. The main principle behind language product lines is to implement DSLs through \textit{language features}. A language feature encapsulates a set of language constructs that represents certain functionality offered by a DSL \cite{Liebig:2013}; they can be combined in different manners to produce tailor-made DSLs. 

Similarly than in the general case of software product lines, language product lines can be built from two different perspectives: top-down, and bottom-up. The top-down perspective is appropriated when language designers know in advance that they will have to build many variants of a DSL, and they have some clues indicating that the effort of building a language product line will be rewarded. In this case, language designers usually start with a domain analysis phase where they acquire, analyze, and structure some domain knowledge provided by the domain experts. Such a knowledge is later used to build an infrastructure consisting of language modules and variability models that will constitute the language product line. 

In turn, the bottom-up perspective is more appropriated when language designers have not a clear overview of the scope of the project. Hence, the effort to build a language product line cannot be easily justified. When this occurs, language designers usually start by the construction of a single DSL. Then, they realize that there is a need for other versions of the DSLs with some particular adaptations for different contexts. In that case, the typical solution is to create new development branches of the initial DSLs and perform the corresponding adaptations. At some point, it becomes impractical and the challenge is to perform a re-engineering process where the different variants of the DSLs are used in the construction of a language product line. Ideally, this process should be supported by some tooling that allows (semi) automation of the process by analyzing and extracting some of the common assets of the language product lines. 

Nowadays, we can find several approaches exploring language product lines engineering. Most of those approaches, however, are more focused on top-down language product lines whereas the bottom-up perspective is rarely studied. As a result, today we can find meta-languages and tool support for the definition of interdependent language features, modeling language variability, and languages configuration. Nevertheless, very few approaches have been proposed to extract language product lines from existing DSLs. 

In this article, we aim to contribute in the construction of bottom-up language product lines. Concretely, we present two contributions. Firstly, we introduce a set of meta-languages and structures that support the specification of a language product line. Secondly, we provide a reverse engineering process to automatically produce a language product line from a set of existing DSLs. This process starts with some static analysis that takes the existing DSLs and identify the commonalities and particularities to extract them a set of interdependent language modules. In addition, we provide an approach to synthesize variability models that represent the existing variability, and that permit the configuration of particular DSLs. We validate our approach through the implementation of a case study on finite state machines. 

The remainder of this article is structured as follows: Section \ref{sec:problemstatement} describes the development scenario behind bottom up language product lines, thus characterizing the situation in which our approach results useful. Section \ref{sec:meta-langauges} presents our first contribution by explaining the meta-languages and structures that we provide to the specification of language product lines. Section \ref{sec:reverse-engineering} presents our reverse engineering process to produce a language product line from a set of existing DSLs. Section \ref{sec:validation} presents the case study that we use as a validation of our approach. Section \ref{sec:limitations} discusses the limitations of our approach. Section \ref{sec:relatedwork} presents a comparison of our approach with the related work. Finally, Section \ref{sec:conclusions} concludes the article. 