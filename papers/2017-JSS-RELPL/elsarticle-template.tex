\documentclass[preprint,5p]{elsarticle}

%\usepackage[sc]{mathpazo}
%\usepackage{wrapfig}
%\usepackage{hyperref}
\usepackage{amsmath,amssymb,amsfonts,mathrsfs}
\usepackage{todonotes}
%\usepackage[amsmath,thmmarks]{ntheorem}
\usepackage{lineno}
\usepackage[colorlinks=true,allcolors=black,breaklinks,draft=false]{hyperref}
%\modulolinenumbers[1]

\journal{Journal of Software and Systems}

%% `Elsevier LaTeX' style
\bibliographystyle{elsarticle-num}

\begin{document}

\begin{frontmatter}

\title{Reverse Engineering Language Product Lines from Existing DSL Variants}

\author{David M\'endez-Acu\~na}
\ead{david.mendez-acuna@inria.fr}

\author{Jos\'e A. Galindo}
\ead{jagalindo@inria.fr}

\author{Beno\^it Combemale}
\ead{benoit.combemale@inria.fr}

\author{Arnaud Blouin}
\ead{arnaud.blouin@inria.fr}

\author{Beno\^it Baudry}
\ead{benoit.baudry@inria.fr}

\address{INRIA/IRISA and University of Rennes 1, France}

\begin{abstract}
The use of domain-specific languages (DSLs) has become a standard to develop complex systems. In this context, an emerging phenomenon is the existence of DSL variants, which are different versions of a DSL adapted to specific purposes but that still share commonalities. In such a case, the challenge for language designers is to reuse, as much as possible, previously defined language constructs to narrow implementation from scratch. To overcome this challenge, recent research in software languages engineering introduced the the notion of \textit{\textbf{language product lines}}. Similarly to software product lines, language product lines are often built through a bottom-up approach: there is a set of existing DSL variants that language designers decompose into several interdependent language modules representing the features of the product line. Besides, they define variability models that capture both commonalities and particularities of the DSL variants. In this article, we propose a reverse-engineering technique to ease-off such a development scenario. Our approach receives a set of DSL variants which are used to automatically recover a language modular design and to synthesize the corresponding variability models. The validation is performed in a project involving industrial partners that required three different variants of a DSL for finite state machines. We use our approach to reverse engineering a language product line, and then we check that the detected variation points correspond to the actual differences among the variants. This validation shows that our approach is able to correctly identify commonalities and variability. Besides, it allows us identifying open issues.

\end{abstract}

\begin{keyword}
Language product lines, software languages engineering, domain-specific languages, reverse-engineering.
\end{keyword}

\end{frontmatter}

%\linenumbers

\input{sections/introduction}
\input{sections/process}
\input{sections/approach}
\input{sections/validation}
%\input{sections/limitations}
\input{sections/related-work}
\input{sections/conclusions}


\section*{Acknowledgments}
This work is supported by the ANR INS Project GEMOC (ANR-12-INSE-0011); the bilateral collaboration VaryMDE between Inria and Thales; the bilateral collaboration FPML between Inria and DGA; and the European Union within the FP7 Marie Curie Initial Training Network â€œRELATE" under grant agreement number 264840.

\appendix

\section{A family of DSLs for state machines}

Generally speaking, state machines are graphs where nodes represent states and arcs represent transitions between the states \cite{Harel:1987}. The execution of a state machine is performed in a sequence of \textit{steps} each of which receives a set of events that the state machine should react to. The reaction of a machine to set of events can be understood as a passage from an initial configuration (t$_i$) to a final configuration (t$_{f}$). A configuration is the set of active states in the machine.

The relationship between the state machine and the arriving events is materialized at the level of the transitions. Each transition is associated to one or more events (also called triggers). When an event arrives, the state machine fires the transitions outgoing from the states in the current configuration whose trigger matches with the event. As a result, the source state of each fired transition is deactivated whereas the corresponding target state is activated. Optionally, guards might be defined on the transitions. A transition is fired if and only if the evaluation of the guard returns true at the moment of the trigger arrival.

The initial configuration of the state machine is given by a set of initial pseudostates.  Transitions outgoing from initial pseudosates are fired automatically when the state machine is initialized. In turn, the execution of a state machine continues until the current configuration is composed only by final states (an special type of states without outgoing transitions).

All of the DSLs included in this project support the notion of region. A state machine might be divided in several regions that are executed concurrently. Each region might have its own initial and final (pseudo)states. In addition, the DSLs also support the definition of different types of actions. States can define entry/do/exit actions, and transitions can have effect actions.

\vspace{2mm}
\textit{\textbf{Abstract syntax variability.}} Differences at the level of the abstract syntax between the DSLs under study correspond to the diversity of constructs each of those DSLs provide. In particular, there are differences in the support for transition's triggers and pseudostates.

In the case of transitions' triggers, whereas Rhapsody only supports atomic triggers, both Harel's statecharts and UML provide support for composite triggers. In Harel's statecharts triggers can be composed by using \texttt{AND}, \texttt{OR}, and \texttt{NOT} operators. In turn, in UML triggers can be composed by using the \texttt{AND} operator.

In the case of pseudostates, whereas all the DSLs support \texttt{Fork}, \texttt{Join}, \texttt{ShallowHistory}, and \texttt{Junction}, there are two psueudostates i.e., \texttt{DeepHistory} and \texttt{Choice} that are only supported by UML. The \texttt{Conditional} pseudostate is only provided by Harel's state charts. Table \ref{fig:oracle} shows the language constructs provided by each DSL.

\begin{table*}[t]
	\centering
	\includegraphics[width=1\linewidth]{images/tab-oracle-statemachines}
	\caption{Diversity of constructs provided by the DSLs for state machines}
	\label{fig:oracle}
\end{table*}

\vspace{2mm}
\textit{\textbf{Semantic variability.}} Semantic differences between the DSLs under study can be summarized in three issues:

\vspace{2mm}
\textit{(1) Events dispatching policy:} The first semantic difference in the operational semantics of state machines refers to the way in which events are consumed by the state machine. In a first interpretation, simultaneous events are supported i.e., the state machine can process more than one event in a single step. In a second interpretation, the state machine follows the principle of run to completion i.e., the state machine is able only of supporting one event by step so several events require several steps.

The semantics of UML and Rhapsody fit the run to completion policy for events dispatching whereas Harel's statecharts support simultaneous events.

\vspace{2mm}
\textit{(2) Execution order of transitions' effects:} It is possible to define actions on the transitions that will affect the execution environment where transitions are fired. These actions are usually known as transitions' effects. All the DSLs for state machines in our family support the expression of such effects. However, there are certain differences regarding their execution.

The first way of executing the effects of a transition is by respecting the order in which they are defined. This is due to the fact that transitions effects are usually defined by means of imperative action script languages where the order of the instructions is intrinsic. The second interpretation to the execution of transitions' effect is to execute them in parallel. In other words, the effects are defined as a set of instructions that will be executed at the same time so no assumptions should be made with respect to the execution order.

UML and Rhapsody execute the transition effects in parallel. Harel's statecharts execute transition effects simultaneously.

\vspace{2mm}
\textit{(3) Priorities in the transitions:} Because several transitions can be associated to the same event, there are cases in which more than one transitions are intended to be fired in the same step. In general, all the DSLs for state machines agree in the fact that all the activated transitions should be fired. However, this is not always possible because conflicts might appear. Consider the state machine presented in Fig \ref{fig:conflicting-priorities}. The transitions $T_D$ and $T_E$ are conflictive because they are activated by the same event i.e., $e_2$, they exit the same state, and they go to different target states. Then, the final configuration of the state machine will be different according to the selected transition.

\begin{figure}[h!]
	\centering
	\includegraphics[width=1\linewidth]{images/conflicting-priorities.pdf}
	\caption{Example of a state machine with conflicting priorities}
	\label{fig:conflicting-priorities}
\end{figure}

To tackle this situation, it is necessary to establish policies that permit to solve such conflicts. Specifically, we need to define a mechanism for prioritizing conflicting transitions so the interpreter is able to easily select a transition from a group of conflicting transitions. One of the best known semantic differences among DSLs for state machines is related with these policies. In particular, there are two different mechanisms for solving this kind of conflicts. A first mechanism for solving conflicting transition is to select the transition with the lower scope. That is, the deeper transition w.r.t. the hierarchy of the state machine.

In the example presented in Fig \ref{fig:conflicting-priorities} the dispatched transition according to this policy would be the transition $T_E$ so the state machine would move to the state $S_5$. The second mechanism for solving conflicts in the transition is to select the transition with the higher scope. That is, the higher transition w.r.t. the hierarchy of the state machine. In the example presented in Fig \ref{fig:conflicting-priorities} the dispatched transition according to this policy is the transition $T_D$ so the state machine will move to the state $S_4$.

The semantics of UML and Rhapsody fits on the first interpretation i.e., deepest transition priority whereas the semantics of Harel's statecharts fits on the second interpretation i.e., highest transitions priority.

%are reified by the fact that not all the DSLs have the same behavior at execution time. For example, whereas Harel's statecharts attend simultaneous events in parallel, both UML and Rhapsody follow the run to completion principle. So, simultaneous events are attended sequentially \cite{Crane:2007}. Consequently, not all the domain-specific actions are the same. In particular, the domain-specific actions \texttt{eval()} and \texttt{step()} in the \texttt{StateMachine} metaclass are different in each DSL.

\section*{References}
\bibliography{mybibfile}

\end{document}
