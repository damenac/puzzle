package fr.inria.diverse.puzzle.examples.compositestates.semantics

import fr.inria.diverse.k3.al.annotationprocessor.Aspect
	
import hfsm.Region
import puzzle.annotations.processor.OverrideRequiredAspectMethod
import java.util.ArrayList
import java.util.Hashtable
import hfsm.Transition
import hfsm.AbstractState
import puzzle.annotations.processor.AddExtensionMethod
import hfsm.State
import java.util.List

@Aspect(className=Region)
class RegionAspect {

	@OverrideRequiredAspectMethod 
	def public void findNewActiveStates(ArrayList<AbstractState> newActiveStates,
		Transition selectedTransition, ArrayList<Transition> currentActiveTransitions, 
		Hashtable<String, Object> context){
			
			// Adding the super states to the current state.
			val ArrayList<AbstractState> targetParents = new ArrayList<AbstractState>()
			_self.getAllParents(selectedTransition.target, targetParents)
			targetParents.forEach[_parent | 
				if(!newActiveStates.contains(_parent))
						newActiveStates.add(_parent);
			]
			
			// Performing the legacy operation
			for(Transition _currentTransition : currentActiveTransitions){
				_self._original_findNewActiveStates(newActiveStates, _currentTransition, currentActiveTransitions, context)
			}
			
			// Removing the states coming from conflicting transitions
			var ArrayList<AbstractState> toDelete = new ArrayList<AbstractState>()
			val ArrayList<AbstractState> targetChildren = new ArrayList<AbstractState>()
			_self.getAllChildren(selectedTransition.source, targetChildren)
	
			for(AbstractState _newState : newActiveStates){
			//Do we can delete all this?
			var boolean delete = true
			var List<Transition> transitions = new ArrayList<Transition>();
			transitions.addAll(_newState.incoming)
			for(AbstractState _children : targetChildren){
				transitions.addAll(_children.incoming)
			}
			for(Transition _incoming : transitions){
				
				if(_newState instanceof State){
					var ArrayList<AbstractState> children = newArrayList
					_self.getAllChildren(_newState, children)
					if(children.findFirst[child | newActiveStates.contains(child)] != null)
						delete = false
				}
				if(currentActiveTransitions.contains(_incoming))
					delete = false
			}
			
			if(delete)
				toDelete.add(_newState)
		}
	}
	
	@AddExtensionMethod
	def public void getAllParents(AbstractState vertex, ArrayList<AbstractState> parents){
		if(vertex instanceof State){
			var State superState = (vertex as State).ownerRegion.ownerState
			while(superState != null){
				if(!parents.contains(superState))
					parents.add(superState);
				superState = superState.ownerRegion.ownerState
			}
		}
	}
	
	@AddExtensionMethod
	def public void getAllChildren(AbstractState vertex, ArrayList<AbstractState> children){
		if(vertex instanceof State){
			if((vertex as State).ownedRegions != null){
				(vertex as State).ownedRegions.forEach[_region|
					children.addAll(_region.subvertex)
					_region.subvertex.forEach[ _vertex |
						_self.getAllChildren(_vertex, children)
					]
				]
			}
		}
	}
}