package fr.inria.diverse.puzzle.examples.fsm.semantics

import fr.inria.diverse.k3.al.annotationprocessor.Aspect
	
import fsm.Region
import java.util.Hashtable
import org.eclipse.emf.common.util.EList
import java.util.ArrayList
import fsm.AbstractState
import fsm.Pseudostate
import fsm.InitialState
import fsm.Transition

@Aspect(className=Region)
class RegionAspect {
	
	def public void initRegion(Hashtable<String, Object> context){
		var ArrayList<AbstractState> regionCurrentState = new ArrayList<AbstractState>();
		context.put(_self.getContextPathByRegion, regionCurrentState)
		
		// Looking for the initial pseudo-state
		var Pseudostate initialPseudostate = _self.subvertex.
						findFirst[ _vertex | (_vertex instanceof Pseudostate) && 
							(_vertex instanceof InitialState)] as Pseudostate
		
		// Dispatching the transitions of the initial pseudo-state
		var ArrayList<AbstractState> initialCurrentState = new ArrayList<AbstractState>()
		var ArrayList<Transition> initialCurrentTransitions = new ArrayList<Transition>()
		for(Transition _transition : initialPseudostate.outgoing){
			initialCurrentTransitions.add(_transition)
			initialCurrentState.add(_transition.target)
		}
		(regionCurrentState as ArrayList<AbstractState>).addAll(initialCurrentState)
		
		initialCurrentTransitions.forEach[ transition |
			transition.evalTransition(context)
		]
		
		
	}
	
	
	def public String getContextPathByRegion(){
		var root = "currentState"
		var ArrayList<Region> parentRegions = new ArrayList<Region>()
		var Region currentRegion = _self
		while(currentRegion.ownerState != null && currentRegion.ownerState.ownerRegion != null){
			parentRegions.add(_self.ownerState.ownerRegion)
			currentRegion = currentRegion.ownerState.ownerRegion
		}
		
		for(var int i = parentRegions.size() - 1; i >= 0; i--){
			root += "-" + parentRegions.get(i).name
		}
		
		return root + "-" + _self.name
	}
	
	/**
	 * Performs a step in the state machine i.e., reads an entry of the input stack and executes it.
	 * If there are several events in the same step they are executed sequentially.  
	 */
	def public void step(Hashtable<String, Object> context, EList<String> events){
		var boolean allJunctionsAttended = false
		
		while(!allJunctionsAttended){
				
			var ArrayList<AbstractState> currentState = _self.getCurrentState(context, events)
			var ArrayList<Transition> currentTransitions = new ArrayList<Transition>()
			
			var ArrayList<AbstractState> attendedStates = new ArrayList<AbstractState>()
			var ArrayList<AbstractState> newStates = new ArrayList<AbstractState>()
			var EList<Transition> activeTransitions = new BasicEList<Transition>()
			
			for(AbstractState _state : currentState){
				activeTransitions.addAll(_self.getActiveTransitions(_state, events))
			}
			println("")
			for(Transition transition : activeTransitions){
				_self.findOldActiveStates(attendedStates, transition, context)
				_self.findNewActiveTransitions(currentTransitions, transition, context)
				_self.findNewActiveStates(newStates, transition, currentTransitions, context)
			}
			
			for(AbstractState _attendedState : attendedStates){
				if(_attendedState instanceof State)
					(_attendedState as State).exitState(context)
			}
			
			_self.removeStatesFromContext(context, attendedStates)
			_self.addStatesToContext(context, newStates)
			
			activeTransitions.forEach[ transition |
				transition.evalTransition(context)
			]
			
			currentTransitions.forEach[ transition |
				if(!transition.alreadyFired(context))
					transition.evalTransition(context)
			]
			
			newStates.forEach[ state |
					state.outgoing.forEach[ transition | transition.resetFired() ]
			]
			
			val ArrayList<AbstractState> currentConditionalState = new ArrayList<AbstractState>
			
			var _it = context.keySet.iterator
			while(_it.hasNext){
				var String _key = _it.next
				var Object _value = context.get(_key)
				if(_key.startsWith("currentState"))
					(_value as ArrayList<AbstractState>).forEach[ _vertex |
						currentConditionalState.add(_vertex)]
			}
		}
		
		var ArrayList<AbstractState> currentState = context.get("currentState-" + _self.name) as ArrayList<AbstractState>
			allJunctionsAttended = !currentState.exists[_vertex | _vertex.outgoing.exists[_outgoing|
				(_outgoing.target instanceof Pseudostate) &&
					(_outgoing.target instanceof Junction)
			]]
	}
	
	/**
	 * Returns the current state of the machine. It corresponds to the current set of active states.
	 */
	def public ArrayList<AbstractState> getCurrentState(Hashtable<String, Object> context, EList<String> events){
		val ArrayList<AbstractState> currentState = new ArrayList<AbstractState>
			
			var _it = context.keySet.iterator
			while(_it.hasNext){
				var String _key = _it.next
				var Object _value = context.get(_key)
				if(_key.startsWith("currentState-" + _self.name))
					(_value as ArrayList<AbstractState>).forEach[ _vertex |
						currentState.add(_vertex)]
			}
		return currentState
	}
	
	/**
	 * Returns the active transitions of a vertex
	 */
	def public EList<Transition> getActiveTransitions(AbstractState vertex, EList<String> events){
		val res = new BasicEList<Transition>();
		for(Transition transition : vertex.outgoing){
			if( (transition.trigger == null) || 
				(transition.trigger != null && transition.trigger.evalTrigger(events) ||
					(transition.target instanceof Pseudostate)
						&& ((transition.target instanceof Junction)))){
				res.add(transition)
			}
		}
		return res;
	}
	
	
}